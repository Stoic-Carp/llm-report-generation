"""PDF report generator using ReportLab."""

import re
from datetime import datetime
from pathlib import Path
from typing import List

from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.lib.units import inch
from reportlab.platypus import (
    Image,
    PageBreak,
    Paragraph,
    SimpleDocTemplate,
    Spacer,
    Table,
    TableStyle,
)

from config.settings import Settings
from src.llm.state import ReportState
from src.utils.logger import app_logger


class PDFGenerator:
    """Generates PDF format reports using ReportLab."""

    def __init__(self, settings: Settings, state: ReportState):
        """Initialize PDF generator.

        Args:
            settings: Application settings.
            state: LangGraph workflow state.
        """
        self.settings = settings
        self.state = state
        self.logger = app_logger
        self.styles = getSampleStyleSheet()
        self._setup_styles()

    def _setup_styles(self):
        """Setup custom paragraph styles."""
        # Title Style
        if "CustomTitle" not in self.styles:
            self.styles.add(
                ParagraphStyle(
                    "CustomTitle",
                    parent=self.styles["Heading1"],
                    fontSize=26,
                    textColor=colors.HexColor("#003667"),  # BMW Blue
                    spaceAfter=30,
                    alignment=TA_CENTER,
                    fontName="Helvetica-Bold",
                )
            )

        # Heading Style
        if "Heading1" in self.styles:
            self.styles["Heading1"].fontSize = 16
            self.styles["Heading1"].textColor = colors.HexColor("#003667")
            self.styles["Heading1"].spaceAfter = 12
            self.styles["Heading1"].fontName = "Helvetica-Bold"

        # SubHeading Style
        if "Heading2" not in self.styles:
            self.styles.add(
                ParagraphStyle(
                    "Heading2",
                    parent=self.styles["Heading1"],
                    fontSize=14,
                    spaceBefore=12,
                    spaceAfter=6,
                    textColor=colors.HexColor("#4a4a4a"),
                )
            )
        else:
            self.styles["Heading2"].fontSize = 14
            self.styles["Heading2"].spaceBefore = 12
            self.styles["Heading2"].spaceAfter = 6
            self.styles["Heading2"].textColor = colors.HexColor("#4a4a4a")

        # Normal Style
        if "Normal" in self.styles:
            self.styles["Normal"].fontSize = 11
            self.styles["Normal"].leading = 14
            self.styles["Normal"].spaceAfter = 10
            self.styles["Normal"].alignment = TA_JUSTIFY

        # Bullet Style
        if "BulletPoint" not in self.styles:
            self.styles.add(
                ParagraphStyle(
                    "BulletPoint",
                    parent=self.styles["Normal"],
                    leftIndent=20,
                    bulletIndent=10,
                    spaceAfter=6,
                )
            )

    def _clean_text(self, text: str) -> str:
        """Convert basic markdown to ReportLab XML tags.

        Args:
            text: Input text with markdown.

        Returns:
            Text formatted for ReportLab Paragraph.
        """
        if not text:
            return ""

        replacements = {
            "–": "-",
            "—": "-",
            "−": "-",
            "‑": "-",
            "‒": "-",
            "―": "-",
            "’": "'",
            "“": '"',
            "”": '"',
            "•": "-",
            "·": "-",
        }
        for old, new in replacements.items():
            text = text.replace(old, new)

        text = re.sub(r"<img[^>]*>", "", text)
        text = re.sub(r"<br\s*/?>", "<br/>", text)
        text = re.sub(r"\t+", " ", text)
        text = re.sub(r"#{2,}\s*", "", text)
        text = re.sub(r"#\s*", "", text)

        text = re.sub(r"\*\*(.*?)\*\*", r"<b>\1</b>", text)
        text = re.sub(r"\*(.*?)\*", r"<i>\1</i>", text)

        return text

    def _create_paragraphs(self, text: str) -> List:
        """Convert markdown-like text into ReportLab flowables.

        Args:
            text: Markdown text generated by the LLM.

        Returns:
            List of flowables (Paragraph, Table, Spacer) ready for PDF rendering.
        """
        if not text:
            return []

        elements: List = []
        lines = text.split("\n")
        buffer: List[str] = []
        idx = 0

        def flush_paragraph():
            if buffer:
                content = " ".join(buffer).strip()
                if content:
                    elements.append(
                        Paragraph(self._clean_text(content), self.styles["Normal"])
                    )
                buffer.clear()

        while idx < len(lines):
            raw_line = lines[idx]
            line = raw_line.strip()

            if not line:
                flush_paragraph()
                idx += 1
                continue

            if self._is_horizontal_rule(line):
                flush_paragraph()
                elements.append(Spacer(1, 0.15 * inch))
                idx += 1
                continue

            if self._is_table_row(line):
                flush_paragraph()
                table_lines, idx = self._extract_table_block(lines, idx)
                table = self._build_table_flowable(table_lines)
                if table:
                    elements.append(table)
                    elements.append(Spacer(1, 0.12 * inch))
                continue

            heading_level = self._heading_level(line)
            if heading_level:
                flush_paragraph()
                heading_text = line[heading_level + 1 :].strip()
                if heading_level == 1:
                    elements.append(
                        Paragraph(
                            self._clean_text(heading_text), self.styles["Heading1"]
                        )
                    )
                elif heading_level == 2:
                    elements.append(
                        Paragraph(
                            self._clean_text(heading_text), self.styles["Heading2"]
                        )
                    )
                else:
                    elements.append(
                        Paragraph(
                            f"<b>{self._clean_text(heading_text)}</b>",
                            self.styles["Normal"],
                        )
                    )
                idx += 1
                continue

            if self._is_bullet(line):
                flush_paragraph()
                bullet_text = self._clean_text(self._strip_bullet_prefix(line))
                elements.append(
                    Paragraph(f"- {bullet_text}", self.styles["BulletPoint"])
                )
                idx += 1
                continue

            buffer.append(line)
            idx += 1

        flush_paragraph()
        return elements

    @staticmethod
    def _is_horizontal_rule(line: str) -> bool:
        """Return True when the line represents a markdown horizontal rule."""
        trimmed = line.replace(" ", "")
        return trimmed and all(char == "-" for char in trimmed)

    @staticmethod
    def _is_table_row(line: str) -> bool:
        """Determine whether a line is part of a markdown table."""
        return line.startswith("|") and line.endswith("|")

    @staticmethod
    def _heading_level(line: str) -> int | None:
        """Identify markdown heading level (1-3) or return None."""
        if line.startswith("### "):
            return 3
        if line.startswith("## "):
            return 2
        if line.startswith("# "):
            return 1
        return None

    @staticmethod
    def _is_bullet(line: str) -> bool:
        """Check for unordered or ordered list markers."""
        if line.startswith(("- ", "* ")):
            return True
        return bool(re.match(r"^\d+\.\s+", line))

    @staticmethod
    def _strip_bullet_prefix(line: str) -> str:
        """Remove bullet prefix from a line."""
        if line.startswith(("- ", "* ")):
            return line[2:].strip()
        return re.sub(r"^\d+\.\s+", "", line).strip()

    def _extract_table_block(
        self, lines: List[str], start_idx: int
    ) -> tuple[List[str], int]:
        """Collect consecutive table lines starting at start_idx."""
        table_lines: List[str] = []
        idx = start_idx
        while idx < len(lines) and self._is_table_row(lines[idx].strip()):
            table_lines.append(lines[idx].strip())
            idx += 1
        return table_lines, idx

    def _build_table_flowable(self, table_lines: List[str]):
        """Convert markdown table lines into a ReportLab Table."""
        if not table_lines:
            return None

        rows: List[List[str]] = []
        for line in table_lines:
            cells = [cell.strip() for cell in line.strip("|").split("|")]
            rows.append(cells)

        if len(rows) < 2:
            return None

        column_count = len(rows[0])
        max_table_width = 6.2 * inch
        col_width = max_table_width / column_count if column_count else max_table_width
        col_widths = [col_width] * column_count

        # Remove alignment row if present (second row with --- markers)
        alignment_row = rows[1]
        if all(self._is_alignment_cell(cell) for cell in alignment_row):
            rows.pop(1)

        formatted_rows: List[List[Paragraph]] = []
        for row in rows:
            formatted_rows.append(
                [
                    Paragraph(self._clean_text(cell) or "-", self.styles["Normal"])
                    for cell in row
                ]
            )

        table = Table(formatted_rows, colWidths=col_widths, hAlign="LEFT")
        style = TableStyle(
            [
                ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor("#a7c2db")),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
                ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                ("FONTNAME", (0, 1), (-1, -1), "Helvetica"),
                ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                ("LEFTPADDING", (0, 0), (-1, -1), 6),
                ("RIGHTPADDING", (0, 0), (-1, -1), 6),
                ("TOPPADDING", (0, 0), (-1, -1), 4),
                ("BOTTOMPADDING", (0, 0), (-1, -1), 4),
                ("GRID", (0, 0), (-1, -1), 0.25, colors.HexColor("#D3D7E0")),
            ]
        )

        for row_idx in range(1, len(rows)):
            if row_idx % 2 == 1:
                style.add(
                    "BACKGROUND",
                    (0, row_idx),
                    (-1, row_idx),
                    colors.HexColor("#F5F7FA"),
                )

        table.setStyle(style)
        return table

    @staticmethod
    def _is_alignment_cell(cell: str) -> bool:
        """Return True if the cell is a markdown alignment specifier."""
        stripped = cell.replace(":", "").replace("-", "")
        return not stripped

    def _start_new_section(self, story: list) -> None:
        """Ensure the next section begins on a new page."""
        if story and not isinstance(story[-1], PageBreak):
            story.append(PageBreak())

    def generate(self) -> str:
        """Generate PDF report.

        Returns:
            Path to generated PDF file.
        """
        self.logger.info("Generating PDF report")

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"bmw_sales_report_{timestamp}.pdf"
        output_path = self.settings.report.output_dir / filename
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Create PDF document
        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=letter,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=72,
        )

        # Build content
        story = self._build_content()

        # Generate PDF
        doc.build(
            story,
            onFirstPage=self._add_header_footer,
            onLaterPages=self._add_header_footer,
        )

        self.logger.info(f"PDF report saved: {output_path}")

        return str(output_path)

    def _build_content(self) -> list:
        """Build PDF content elements.

        Returns:
            List of Flowable elements.
        """
        story = []

        # Title page
        story.append(Spacer(1, 2 * inch))
        story.append(
            Paragraph(self.settings.report.company_name, self.styles["CustomTitle"])
        )
        story.append(Spacer(1, 0.5 * inch))
        story.append(
            Paragraph(
                f"<b>Generated:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                self.styles["Normal"],
            )
        )
        story.append(
            Paragraph(
                f"<b>Author:</b> {self.settings.report.author}", self.styles["Normal"]
            )
        )
        story.append(PageBreak())

        # Executive Summary
        if self.state.get("executive_summary"):
            self._start_new_section(story)
            story.append(Paragraph("Executive Summary", self.styles["Heading1"]))
            story.append(Spacer(1, 0.1 * inch))
            story.extend(self._create_paragraphs(self.state["executive_summary"]))
            story.append(Spacer(1, 0.3 * inch))

        # Analysis Sections
        if self.state.get("analysis_sections"):
            sections = self.state["analysis_sections"]

            if "sales_trends" in sections:
                self._start_new_section(story)
                story.append(
                    Paragraph("Sales Performance Trends", self.styles["Heading1"])
                )
                story.extend(self._create_paragraphs(sections["sales_trends"]))
                story.append(Spacer(1, 0.2 * inch))

            if "regional_analysis" in sections:
                self._start_new_section(story)
                story.append(Paragraph("Regional Analysis", self.styles["Heading1"]))
                story.extend(self._create_paragraphs(sections["regional_analysis"]))
                story.append(Spacer(1, 0.2 * inch))

            if "product_performance" in sections:
                self._start_new_section(story)
                story.append(Paragraph("Product Performance", self.styles["Heading1"]))
                story.extend(self._create_paragraphs(sections["product_performance"]))
                story.append(Spacer(1, 0.2 * inch))

        # Visualizations
        if self.state.get("plot_paths"):
            self._start_new_section(story)
            story.append(Paragraph("Visualizations", self.styles["Heading1"]))
            story.append(Spacer(1, 0.2 * inch))

            charts_added = 0
            for plot_path in self.state["plot_paths"]:
                if Path(plot_path).exists():
                    try:
                        # Extract title from filename roughly
                        path_obj = Path(plot_path)
                        name_parts = path_obj.stem.split("_")
                        if len(name_parts) > 2:
                            # Skip 'plot' and number
                            clean_title = " ".join(name_parts[2:]).title()
                            story.append(
                                Paragraph(clean_title, self.styles["Heading2"])
                            )

                        img = Image(plot_path, width=6 * inch, height=4 * inch)
                        story.append(img)
                        story.append(Spacer(1, 0.3 * inch))
                        story.append(PageBreak())
                        charts_added += 1
                    except Exception as e:
                        self.logger.warning(f"Could not add image {plot_path}: {e}")

            if charts_added and isinstance(story[-1], PageBreak):
                story.pop()

        # Recommendations
        if self.state.get("recommendations"):
            self._start_new_section(story)
            story.append(Paragraph("Recommendations", self.styles["Heading1"]))
            story.append(Spacer(1, 0.2 * inch))

            for rec in self.state["recommendations"]:
                story.append(
                    Paragraph(f"- {self._clean_text(rec)}", self.styles["BulletPoint"])
                )

        return story

    def _add_header_footer(self, canvas, doc):
        """Add header and footer to pages.

        Args:
            canvas: ReportLab canvas object.
            doc: Document object.
        """
        canvas.saveState()

        # Header line
        canvas.setStrokeColor(colors.HexColor("#003667"))
        canvas.setLineWidth(1)
        canvas.line(
            72, doc.pagesize[1] - 60, doc.pagesize[0] - 72, doc.pagesize[1] - 60
        )

        # Header Text
        canvas.setFont("Helvetica-Bold", 9)
        canvas.drawRightString(
            doc.pagesize[0] - 72,
            doc.pagesize[1] - 50,
            "BMW Sales Analysis Report",
        )

        # Footer line
        canvas.line(72, 50, doc.pagesize[0] - 72, 50)

        # Footer - Page Number
        canvas.setFont("Helvetica", 9)
        page_num = canvas.getPageNumber()
        page_text = f"Page {page_num}"
        text_width = canvas.stringWidth(page_text, "Helvetica", 9)
        canvas.drawString(
            (doc.pagesize[0] - text_width) / 2.0,
            30,
            page_text,
        )

        # Footer - Date
        date_text = datetime.now().strftime("%Y-%m-%d")
        canvas.drawString(72, 30, date_text)

        canvas.restoreState()
